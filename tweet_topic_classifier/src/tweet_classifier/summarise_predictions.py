"""Produce summary outputs from inference results."""

from __future__ import annotations

import argparse
from pathlib import Path
from typing import List

import matplotlib.pyplot as plt
import pandas as pd
from matplotlib.backends.backend_pdf import PdfPages

TOPICS = [
    "immigration",
    "climate change",
    "renewable energy",
    "traditional energy",
    "inequality",
    "social policy",
    "taxation",
    "labour market",
    "international trade",
    "economics",
    "european union",
    "public health",
    "gender rights",
    "civil rights",
    "political rights",
    "connecting",
    "elections/voting",
    "self-promotion",
    "anti-establishment",
]


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Create summary artefacts for model predictions.")
    parser.add_argument(
        "--input",
        default=Path("data/processed/inference_results.csv"),
        type=Path,
        help="CSV containing model predictions.",
    )
    parser.add_argument(
        "--sample-output",
        default=Path("data/processed/topic_samples.csv"),
        type=Path,
        help="Destination for the topic-balanced sample.",
    )
    parser.add_argument(
        "--report",
        default=Path("reports/topic_frequency.pdf"),
        type=Path,
        help="PDF file summarising topic counts.",
    )
    parser.add_argument("--sample-size", type=int, default=20, help="Rows per topic in the sample dataset.")
    return parser.parse_args()


def load_predictions(path: Path) -> pd.DataFrame:
    df = pd.read_csv(path)
    if "predicted_labels" not in df.columns:
        raise KeyError("Expected 'predicted_labels' column generated by run_inference.py.")
    if isinstance(df.loc[0, "predicted_labels"], str):
        df["predicted_labels"] = df["predicted_labels"].apply(eval)
    return df


def expand_labels(df: pd.DataFrame) -> pd.DataFrame:
    expanded = df.copy()
    for idx, topic in enumerate(TOPICS):
        expanded[topic] = expanded["predicted_labels"].apply(lambda values: int(values[idx]) if idx < len(values) else 0)
    expanded["no_topic"] = expanded[TOPICS].sum(axis=1).eq(0).astype(int)
    return expanded


def build_topic_sample(df: pd.DataFrame, sample_size: int) -> pd.DataFrame:
    samples = []
    for topic in TOPICS:
        topic_rows = df[df[topic] == 1]
        if topic_rows.empty:
            continue
        samples.append(topic_rows.sample(n=min(sample_size, len(topic_rows)), random_state=42).assign(topic=topic))
    no_topic_rows = df[df["no_topic"] == 1]
    if not no_topic_rows.empty:
        samples.append(
            no_topic_rows.sample(n=min(sample_size, len(no_topic_rows)), random_state=42).assign(topic="no_topic")
        )
    if not samples:
        return pd.DataFrame(columns=list(df.columns) + ["topic"])
    return pd.concat(samples).reset_index(drop=True)


def save_topic_chart(counts: pd.Series, report_path: Path) -> None:
    report_path.parent.mkdir(parents=True, exist_ok=True)
    with PdfPages(report_path) as pdf:
        plt.figure(figsize=(12, 6))
        counts.plot(kind="bar", color="steelblue", edgecolor="black")
        plt.ylabel("Number of tweets")
        plt.xlabel("Topic")
        plt.title("Predicted topic distribution")
        plt.xticks(rotation=45, ha="right")
        plt.tight_layout()
        pdf.savefig()
        plt.close()

        fig, ax = plt.subplots(figsize=(8.27, 11.69))  # A4 portrait
        ax.axis("off")
        table = ax.table(
            cellText=list(zip(counts.index, counts.values)),
            colLabels=["Topic", "Count"],
            loc="center",
        )
        table.auto_set_font_size(False)
        table.set_fontsize(10)
        table.scale(1, 1.4)
        pdf.savefig()
        plt.close(fig)


def main() -> None:
    args = parse_args()
    df = load_predictions(args.input)
    expanded = expand_labels(df)

    counts = expanded[TOPICS + ["no_topic"]].sum()
    sample = build_topic_sample(expanded, args.sample_size)

    args.sample_output.parent.mkdir(parents=True, exist_ok=True)
    sample.to_csv(args.sample_output, index=False)
    save_topic_chart(counts, args.report)


if __name__ == "__main__":
    main()
